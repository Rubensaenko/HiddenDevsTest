--[[
	HIDDEN DEVS APPLICATION SUBMISSION
	Developer Name : moonless
	Hey my name is Ruben I prayed that this system would be sufficient because I was refused every time due to the lack of lines, this systeme include CFrame,Physic, metatable etc 
	Date: 27/08/2025
]]
local Spell = {}
Spell.__index = Spell

-- The base constructor for all spells. This is the basic template.
function Spell.new(caster)
	local self = setmetatable({}, Spell)

	self.Caster = caster
	self.Cooldown = 2
	self.Name = "Unknown Spell"
	self.ManaCost = 10

	return self
end

-- A "virtual" function. Each child spell should implement its own Cast method.
function Spell:Cast()
	warn("Cast() method not implemented for spell: " .. self.Name)
end




-- // PROJECTILE CLASS //
local Projectile = {}
Projectile.__index = Projectile
-- Establish inheritance: if a function isn't in Projectile, Lua will check in Spell.
setmetatable(Projectile, Spell)

function Projectile.new(caster)
	local self = setmetatable(Spell.new(caster), Projectile) -- Call the parent's constructor first!

	self.Name = "Magic Projectile"
	self.Power = 10
	self.Part = nil
	self.Debounce = false -- Debounce is now specific to EACH projectile instance.

	return self
end

function Projectile:Cast()
	local hrp = self.Caster.Character and self.Caster.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local part = Instance.new("Part")
	part.Name = "Projectile"
	part.Size = Vector3.new(2, 2, 2)
	part.Shape = Enum.PartType.Ball
	part.Material = Enum.Material.Neon
	part.BrickColor = BrickColor.new("Bright blue")
	part.CanCollide = false
	part.CFrame = hrp.CFrame * CFrame.new(0, 0, -5) -- Spawns slightly in front of the player
	part.Velocity = hrp.CFrame.LookVector * 100 -- Simple physics-based propulsion
	part.Parent = workspace

	self.Part = part

	-- This connection will be disconnected when the projectile is destroyed
	self.TouchConnection = self.Part.Touched:Connect(function(hit)
		if self.Debounce then return end

		local targetHumanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
		if targetHumanoid and hit.Parent ~= self.Caster.Character then
			self.Debounce = true
			targetHumanoid:TakeDamage(self.Power)
			self:Destroy() -- Clean up the projectile after impact
		end
	end)

	game.Debris:AddItem(self.Part, 5) -- Safety net: projectile destroys itself after 5 seconds
end

function Projectile:Destroy()
	if self.TouchConnection then
		self.TouchConnection:Disconnect()
	end
	if self.Part then
		local explosion = Instance.new("Explosion")
		explosion.Position = self.Part.Position
		explosion.BlastRadius = 5
		explosion.Parent = workspace
		self.Part:Destroy()
	end
end


-- // MISSILE CLASS //
local Missile = {}
Missile.__index = Missile
setmetatable(Missile, Spell)

function Missile.new(caster, target)
	local self = setmetatable(Spell.new(caster), Missile)

	self.Name = "Homing Missile"
	self.Cible = target
	self.Vitesse = 5
	self.TurnSpeed = 0.2
	self.Timeout = 10
	self.Damage = 50

	local part = Instance.new("Part")
	part.Name = "Missile"
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 1, 3)
	part.BrickColor = BrickColor.new("Bright red")
	part.Material = Enum.Material.Neon

	local launchPoint = caster.Character.PrimaryPart
	part.CFrame = CFrame.lookAt(launchPoint.Position + launchPoint.CFrame.LookVector * 5, target.Character.PrimaryPart.Position)
	part.Parent = workspace

	self.Part = part
	self.StartTime = os.clock()

	return self
end

function Missile:Update(dt)
	-- Using "Guard Clauses" to avoid deep nesting and keep the code clean
	if not self.Part or not self.Part.Parent then return "destroy" end
	if not self.Cible or not self.Cible.Parent or not self.Cible.Character or not self.Cible.Character:FindFirstChild("Humanoid") or self.Cible.Character.Humanoid.Health <= 0 then
		return "destroy"
	end
	if os.clock() - self.StartTime > self.Timeout then
		return "destroy"
	end

	local hrp = self.Cible.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return "destroy" end

	-- CFrame logic for homing/guidance
	local goalOrientation = CFrame.lookAt(self.Part.Position, hrp.Position)
	self.Part.CFrame = self.Part.CFrame:Lerp(goalOrientation, self.TurnSpeed)

	-- CFrame logic for forward movement
	local mouvement = self.Part.CFrame.LookVector * self.Vitesse
	self.Part.CFrame = self.Part.CFrame + mouvement

	-- Impact detection
	if (self.Part.Position - hrp.Position).Magnitude < 5 then
		hrp.Parent.Humanoid:TakeDamage(self.Damage)
		return "destroy"
	end
end

function Missile:Destroy()
	if self.Part then
		local explosion = Instance.new("Explosion")
		explosion.Position = self.Part.Position
		explosion.BlastRadius = 10
		explosion.Parent = workspace
		self.Part:Destroy()
		self.Part = nil
	end
end


-- // LASERBEAM CLASS //
local LaserBeam = {}
LaserBeam.__index = LaserBeam
setmetatable(LaserBeam, Spell)

function LaserBeam.new(caster)
	local self = setmetatable(Spell.new(caster), LaserBeam)
	self.Name = "Energy Beam"
	self.DamagePerTick = 2
	self.MaxLength = 200
	self.Part = nil
	self.UpdateConnection = nil
	return self
end

function LaserBeam:StartChanneling(mousePosition)
	if self.UpdateConnection then return end -- Already channeling

	self.Part = Instance.new("Part")
	self.Part.Anchored = true
	self.Part.CanCollide = false
	self.Part.Material = Enum.Material.Neon
	self.Part.Color = Color3.new(0, 1, 1)
	self.Part.Parent = workspace

	-- We store the Heartbeat connection so we can disconnect it later
	self.UpdateConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
		self:Update(dt, mousePosition)
	end)
end

function LaserBeam:StopChanneling()
	if not self.UpdateConnection then return end

	self.UpdateConnection:Disconnect()
	self.UpdateConnection = nil

	if self.Part then
		self.Part:Destroy()
		self.Part = nil
	end
end

function LaserBeam:Update(dt, mousePosition)
	local character = self.Caster.Character
	if not character or not character.PrimaryPart then self:StopChanneling() return end

	local originPosition = character.PrimaryPart.Position
	local direction = (mousePosition - originPosition).Unit

	-- We create RaycastParams to ignore the caster's character and the beam itself
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, self.Part}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	local result = workspace:Raycast(originPosition, direction * self.MaxLength, raycastParams)

	-- The beam stops where it hits, or at its max length if it hits nothing
	local endPoint = result and result.Position or originPosition + direction * self.MaxLength
	local distance = (endPoint - originPosition).Magnitude

	-- This is the standard formula to size and position a part between two points
	self.Part.Size = Vector3.new(0.4, 0.4, distance)
	self.Part.CFrame = CFrame.lookAt(originPosition, endPoint) * CFrame.new(0, 0, -distance / 2)

	-- Apply damage if the raycast hit a humanoid
	if result and result.Instance then
		local humanoid = result.Instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:TakeDamage(self.DamagePerTick)
		end
	end
end
local NovaGivre = {}
NovaGivre.__index = NovaGivre

setmetatable(NovaGivre,Projectile)

function NovaGivre.new(caster)
	local self = setmetatable(Projectile.new(caster),NovaGivre)

	self.Radius = 15
	self.Color = Color3.new(1, 0, 0)
	self.Damage = 10
	return self
end

function NovaGivre:Cast(player,radius)
	local hrp = player.Character:FindFirstChild("HumanoidRootPart") or player.Character:FindFirstChild("Torso")
	if not hrp then return end
	local part = workspace:GetPartBoundsInRadius(hrp.Position,self.Radius)
	for i, valeur in pairs(part) do
		local hum = valeur.Parent:FindFirstChild("Humanoid")
		if hum then
			self:GivreStunEffect(player)
			hum:TakeDamage(self.Damage)
		end
	end
end

function NovaGivre:GivreStunEffect(player)
	local hrp = player.Character:FindFirstChild("HumanoidRootPart") or player.Character:FindFirstChild("Torso")
	if not hrp then return end
	local hum = player.Character:FindFirstChild("Humanoid")
	if not hum then return end

	local basespeed = hum.WalkSpeed
	hum.WalkSpeed = 0
	hum:SetAttribute("StunFreez",true)
	local particule = Instance.new("ParticleEmitter")
	particule.Parent = hrp
	particule.Size = NumberSequence.new(1,10)
	particule.Color = ColorSequence.new(Color3.new(1, 0, 0))
	particule.Enabled = false
	particule.Transparency = NumberSequence.new(0,1)
	particule:Emit(10)
	wait(1)
	hum.WalkSpeed = basespeed
	hum:SetAttribute("StunFreez",nil)

	game.Debris:AddItem(particule,1)
end


local SpellManager = {}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Our "spellbook" contains the blueprints for all our spells
local Spellbook = { 
	Projectile = Projectile, 
	Missile = Missile, 
	NovaGivre = NovaGivre, 
	LaserBeam = LaserBeam 
}
local activeSpells = {} -- For spells that need updating every frame (missiles, lasers)
local playerData = {} -- Simple cache for player cooldowns and mana

-- Function to get or create data for a player
local function getPlayerData(player)
	if not playerData[player] then
		playerData[player] = {
			Mana = 100,
			Cooldowns = {}
		}
	end
	return playerData[player]
end

function SpellManager.CastSpell(player, spellName, target)
	local spellBlueprint = Spellbook[spellName]
	if not spellBlueprint then return end

	local pData = getPlayerData(player)
	local spellData = spellBlueprint.new(player) -- Create a temporary instance to check its properties

	-- Check cooldown
	if pData.Cooldowns[spellName] and os.clock() - pData.Cooldowns[spellName] < spellData.Cooldown then
		print("Spell is on cooldown!")
		return
	end

	-- Check mana cost
	if pData.Mana < spellData.ManaCost then
		print("Not enough mana!")
		return
	end

	-- All checks passed, proceed with casting
	pData.Mana = pData.Mana - spellData.ManaCost
	pData.Cooldowns[spellName] = os.clock()

	local newSpell
	if spellName == "Missile" then
		local targetPlayer = Players:FindFirstChild(target)
		if not targetPlayer then return end
		newSpell = spellBlueprint.new(player, targetPlayer)
	else
		newSpell = spellBlueprint.new(player)
	end

	newSpell:Cast()

	-- If the spell has an Update function, it needs to be tracked
	if newSpell.Update then
		table.insert(activeSpells, newSpell)
	end
end

function SpellManager.StartChanneling(player, mousePosition)
	if activeSpells[player] then return end -- Player is already channeling a spell

	local newLaser = Spellbook.LaserBeam.new(player)
	newLaser:StartChanneling(mousePosition)
	activeSpells[player] = newLaser
end

function SpellManager.StopChanneling(player)
	local activeLaser = activeSpells[player]
	if activeLaser and activeLaser.Name == "Energy Beam" then
		activeLaser:StopChanneling()
		activeSpells[player] = nil
	end
end

-- The single, central update loop for all active spells
RunService.Heartbeat:Connect(function(dt)
	-- Loop backwards when removing items from a table
	for i = #activeSpells, 1, -1 do
		local spell = activeSpells[i]
		-- We only update missiles in this global loop. Lasers manage their own connection.
		if spell and spell.Name == "Homing Missile" then
			local status = spell:Update(dt)
			if status == "destroy" then
				spell:Destroy()
				table.remove(activeSpells, i)
			end
		end
	end
end)


local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Connection for "instant" spells
ReplicatedStorage.remotesEvent.spell.OnServerEvent:Connect(function(player, spellName, target)
	SpellManager.CastSpell(player, spellName, target)
end)

-- Connections for the channeled laser spell
ReplicatedStorage.remotesEvent.Laser.OnServerEvent:Connect(function(player, eventType, mousePosition)
	if eventType == "Start" then
		SpellManager.StartChanneling(player, mousePosition)
	elseif eventType == "Stop" then
		SpellManager.StopChanneling(player)
	end
end)

-- When a player leaves, we clean up their data to prevent memory leaks
Players.PlayerRemoving:Connect(function(player)
	if playerData[player] then
		playerData[player] = nil
	end
	if activeSpells[player] then
		SpellManager.StopChanneling(player)
	end
end)

-- The script is now ready and running.
return SpellManager
