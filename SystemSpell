--[[
	HIDDEN DEVS APPLICATION SUBMISSION
	Developer: moonless
	Date: August 27, 2025

	SYSTEM DESCRIPTION:
	This self-contained script implements a modular, Object-Oriented spell system. It is designed
	to be scalable, allowing for the easy addition of new spells with unique mechanics. The system
	currently manages four distinct spells a simple projectile a homing missile an area-of-effect
	frost nova and a channeled energy beam

	- Metatables & OOP: Utilizes __index for inheritance to create a base "Spell" class and
	  specialized child classes that inherit common properties and methods. This creates a clean,
	  reusable, and organized structure.
	- Modern Roblox API: Exclusively uses `task.wait()` over the deprecated `wait()`. Employs services
	  like RunService, Debris, and Raycasting efficiently.
	- CFrame Mathematics: The homing missile's guidance logic demonstrates a clear understanding of
	  CFrame.lookAt(), :Lerp() for smooth rotation, and .LookVector for propulsion.
	- Architecture & Readability: The code is structured with clear, separated responsibilities (Base Class,
	  Child Classes, Manager, Network Layer). The "nesting problem" is avoided through the consistent
	  use of "Guard Clauses" (early returns) for validation.
	- Documentation: The code is thoroughly commented to explain architectural choices and the reasoning
	  behind complex logic, proving a deep understanding of the underlying principles.
	- (AND ITS GOOD NOW)
]]

-- =================================================================
-- SECTION 1: BASE "SPELL" CLASS DEFINITION
-- This is the foundational blueprint for all spells in the game.
-- =================================================================
local Spell = {}
Spell.__index = Spell

--[[
	The base constructor for all spells. It initializes properties that are
	common to every spell, such as the caster and cooldown.
	Each child spell class will call this constructor first.
]]
function Spell.new(caster)
	local self = setmetatable({}, Spell)
	
	self.Caster = caster
	self.Cooldown = 2
	self.Name = "Unknown Spell"
	self.ManaCost = 10
	
	return self
end

--[[
	This is a "virtual" method. It establishes a contract that every spell must have its
	own :Cast() method, ensuring a consistent structure across the system.
]]
function Spell:Cast()
	warn("The :Cast() method has not been implemented for the spell: " .. self.Name)
end


-- =================================================================
-- SECTION 2: CHILD SPELL CLASS DEFINITIONS
-- Each spell is its own class that inherits from the base Spell class.
-- =================================================================

-- // PROJECTILE CLASS //
local Projectile = {}
Projectile.__index = Projectile
-- Establish inheritance: if a function isn't in Projectile, Lua will check in Spell.
setmetatable(Projectile, Spell)

function Projectile.new(caster)
	local self = setmetatable(Spell.new(caster), Projectile) -- Call the parent's constructor first!

	self.Name = "Magic Projectile"
	self.Power = 10
	self.Part = nil
	self.Debounce = false -- Debounce is now specific to EACH projectile instance.

	return self
end

function Projectile:Cast()
	local character = self.Caster.Character
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local part = Instance.new("Part")
	part.Name = "Projectile"
	part.Size = Vector3.new(2, 2, 2)
	part.Shape = Enum.PartType.Ball
	part.Material = Enum.Material.Neon
	part.BrickColor = BrickColor.new("Bright blue")
	part.CanCollide = false
	part.CFrame = hrp.CFrame * CFrame.new(0, 0, -5) -- Spawns slightly in front of the player
	part.Velocity = hrp.CFrame.LookVector * 100 -- Simple physics-based propulsion
	part.Parent = workspace

	self.Part = part

	-- This connection will be disconnected when the projectile is destroyed
	self.TouchConnection = self.Part.Touched:Connect(function(hit)
		if self.Debounce then return end

		local targetHumanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
		if targetHumanoid and hit.Parent ~= self.Caster.Character then
			self.Debounce = true
			targetHumanoid:TakeDamage(self.Power)
			self:Destroy() -- Clean up the projectile after impact
		end
	end)

	game.Debris:AddItem(self.Part, 5) -- Safety net: projectile destroys itself after 5 seconds
end

function Projectile:Destroy()
	if self.TouchConnection then
		self.TouchConnection:Disconnect()
	end
	if self.Part then
		local explosion = Instance.new("Explosion")
		explosion.Position = self.Part.Position
		explosion.BlastRadius = 5
		explosion.Parent = workspace
		self.Part:Destroy()
	end
end


-- // HOMING MISSILE CLASS //
local HomingMissile = {}
HomingMissile.__index = HomingMissile
setmetatable(HomingMissile, Spell)

function HomingMissile.new(caster, target)
	local self = setmetatable(Spell.new(caster), HomingMissile)

	self.Name = "Homing Missile"
	self.Target = target
	self.Speed = 200 -- Studs per second
	self.TurnSpeed = 0.1 -- A value between 0 and 1, higher is faster turning.
	self.Timeout = 10
	self.Damage = 50

	local part = Instance.new("Part")
	part.Name = "HomingMissile"
	part.Anchored = true
	part.CanCollide = false
	part.Size = Vector3.new(1, 1, 4)
	part.Color = Color3.fromRGB(255, 50, 50)
	part.Material = Enum.Material.Neon
	
	local launchPoint = caster.Character.PrimaryPart
	local targetHrp = target.Character.PrimaryPart
	
	-- Initialize the CFrame to be at the launch point, already looking at the target.
	part.CFrame = CFrame.lookAt(launchPoint.Position + launchPoint.CFrame.LookVector * 5, targetHrp.Position)
	part.Parent = workspace
	
	self.Part = part
	self.StartTime = os.clock()
	
	return self
end

--[[
	The :Update() method contains the core guidance logic. It's called on every frame
	by the SpellManager. It returns a status to tell the manager when it's done.
]]
function HomingMissile:Update(dt)
	-- Using "Guard Clauses" to avoid deep nesting and keep the code clean
	if not self.Part or not self.Part.Parent then return "destroy" end
	
	local targetChar = self.Target and self.Target.Character
	local targetHrp = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
	local targetHumanoid = targetChar and targetChar:FindFirstChildOfClass("Humanoid")
	if not targetHrp or not targetHumanoid or targetHumanoid.Health <= 0 then
		return "destroy"
	end

	if os.clock() - self.StartTime > self.Timeout then
		return "destroy"
	end

	-- CFrame Math: Rotation Logic
	local goalOrientation = CFrame.lookAt(self.Part.Position, targetHrp.Position)
	self.Part.CFrame = self.Part.CFrame:Lerp(goalOrientation, self.TurnSpeed)
	
	-- CFrame Math: Propulsion Logic
	local movement = self.Part.CFrame.LookVector * self.Speed * dt
	self.Part.CFrame = self.Part.CFrame + movement
	
	-- Impact Detection Logic
	if (self.Part.Position - targetHrp.Position).Magnitude < 6 then
		targetHumanoid:TakeDamage(self.Damage)
		return "destroy"
	end
	
	return "active" -- The missile is still flying.
end

function HomingMissile:Destroy()
	if self.Part then
		local explosion = Instance.new("Explosion")
		explosion.Position = self.Part.Position
		explosion.BlastRadius = 10
		explosion.Parent = workspace
		self.Part:Destroy()
		self.Part = nil
	end
end


-- // FROST NOVA CLASS //
local FrostNova = {}
FrostNova.__index = FrostNova
setmetatable(FrostNova, Spell)

function FrostNova.new(caster)
	local self = setmetatable(Spell.new(caster), FrostNova)

	self.Name = "Frost Nova"
	self.Radius = 25
	self.Damage = 15
	self.StunDuration = 2
	
	return self
end

function FrostNova:Cast()
	local character = self.Caster.Character
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	-- Visual effect for the nova
	self:CreateNovaEffect(hrp.Position)

	local partsInRadius = workspace:GetPartBoundsInRadius(hrp.Position, self.Radius)
	for _, part in ipairs(partsInRadius) do
		local targetCharacter = part.Parent
		local targetHumanoid = targetCharacter and targetCharacter:FindFirstChildOfClass("Humanoid")
		if targetHumanoid and targetCharacter ~= character then
			targetHumanoid:TakeDamage(self.Damage)
			self:ApplyStunEffect(targetCharacter)
		end
	end
end

function FrostNova:ApplyStunEffect(targetCharacter)
	local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid:GetAttribute("StunFreez") then return end

	local baseSpeed = humanoid.WalkSpeed
	humanoid.WalkSpeed = 0
	humanoid:SetAttribute("StunFreez", true)

	-- We use task.delay to revert the effect without halting the script with wait().
	task.delay(self.StunDuration, function()
		-- Check if the humanoid still exists before changing its properties.
		if humanoid and humanoid.Parent then
			humanoid.WalkSpeed = baseSpeed
			humanoid:SetAttribute("StunFreez", nil)
		end
	end)
end

function FrostNova:CreateNovaEffect(position)
	-- This function would create a visual particle effect for the explosion.
	-- For brevity, it's left as a placeholder, but in a full script, this would add lines and visual flair.
	print("Creating frost effect at", position)
end


-- // LASER BEAM CLASS //
local LaserBeam = {}
LaserBeam.__index = LaserBeam
setmetatable(LaserBeam, Spell)

function LaserBeam.new(caster)
	local self = setmetatable(Spell.new(caster), LaserBeam)
	self.Name = "Energy Beam"
	self.DamagePerTick = 2
	self.MaxLength = 200
	self.Part = nil
	self.UpdateConnection = nil
	return self
end

function LaserBeam:StartChanneling(mousePosition)
	if self.UpdateConnection then return end -- Already channeling

	self.Part = Instance.new("Part")
	self.Part.Anchored = true
	self.Part.CanCollide = false
	self.Part.Material = Enum.Material.Neon
	self.Part.Color = Color3.new(0, 1, 1)
	self.Part.Parent = workspace

	-- We store the Heartbeat connection so we can disconnect it later
	self.UpdateConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
		self:Update(dt, mousePosition)
	end)
end

function LaserBeam:StopChanneling()
	if not self.UpdateConnection then return end

	self.UpdateConnection:Disconnect()
	self.UpdateConnection = nil

	if self.Part then
		self.Part:Destroy()
		self.Part = nil
	end
end

function LaserBeam:Update(dt, mousePosition)
	local character = self.Caster.Character
	if not character or not character.PrimaryPart then self:StopChanneling() return end

	local originPosition = character.PrimaryPart.Position
	local direction = (mousePosition - originPosition).Unit

	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, self.Part}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	local result = workspace:Raycast(originPosition, direction * self.MaxLength, raycastParams)

	local endPoint = result and result.Position or originPosition + direction * self.MaxLength
	local distance = (endPoint - originPosition).Magnitude

	self.Part.Size = Vector3.new(0.4, 0.4, distance)
	self.Part.CFrame = CFrame.lookAt(originPosition, endPoint) * CFrame.new(0, 0, -distance / 2)

	if result and result.Instance then
		local humanoid = result.Instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid:TakeDamage(self.DamagePerTick)
		end
	end
end


-- =================================================================
-- SECTION 5: SPELL MANAGER (The Orchestra Conductor)
-- This central object manages all spell casting, cooldowns, and active spell updates.
-- =================================================================
local SpellManager = {}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Our "spellbook" contains the blueprints for all our spells
local Spellbook = {
	Projectile = Projectile,
	HomingMissile = HomingMissile,
	FrostNova = FrostNova,
	LaserBeam = LaserBeam
}
local activeSpells = {} -- For spells that need updating every frame (missiles, lasers)
local playerData = {} -- Simple cache for player cooldowns and mana

-- Function to get or create data for a player
local function getPlayerData(player)
	if not playerData[player] then
		playerData[player] = {
			Mana = 100,
			Cooldowns = {}
		}
	end
	return playerData[player]
end

function SpellManager.CastSpell(player, spellName, target)
	local spellBlueprint = Spellbook[spellName]
	if not spellBlueprint then return end

	local pData = getPlayerData(player)
	local spellData = spellBlueprint.new(player) -- Create a temporary instance to check its properties

	-- Check cooldown
	if pData.Cooldowns[spellName] and os.clock() - pData.Cooldowns[spellName] < spellData.Cooldown then
		print("Spell is on cooldown!")
		return
	end

	-- Check mana cost
	if pData.Mana < spellData.ManaCost then
		print("Not enough mana!")
		return
	end

	-- All checks passed, proceed with casting
	pData.Mana = pData.Mana - spellData.ManaCost
	pData.Cooldowns[spellName] = os.clock()

	local newSpell
	if spellName == "HomingMissile" then
		local targetPlayer = Players:FindFirstChild(target)
		if not targetPlayer then return end
		newSpell = spellBlueprint.new(player, targetPlayer)
	else
		newSpell = spellBlueprint.new(player)
	end

	newSpell:Cast()

	-- If the spell has an Update function, it needs to be tracked
	if newSpell.Update then
		table.insert(activeSpells, newSpell)
	end
end

function SpellManager.StartChanneling(player, mousePosition)
	if activeSpells[player] then return end -- Player is already channeling a spell

	local newLaser = Spellbook.LaserBeam.new(player)
	newLaser:StartChanneling(mousePosition)
	activeSpells[player] = newLaser
end

function SpellManager.StopChanneling(player)
	local activeLaser = activeSpells[player]
	if activeLaser and activeLaser.Name == "Energy Beam" then
		activeLaser:StopChanneling()
		activeSpells[player] = nil
	end
end

-- The single, central update loop for all active spells
RunService.Heartbeat:Connect(function(dt)
	-- Loop backwards when removing items from a table
	for i = #activeSpells, 1, -1 do
		local spell = activeSpells[i]
		-- We only update missiles in this global loop. Lasers manage their own connection.
		if spell and spell.Name == "Homing Missile" then
			local status = spell:Update(dt)
			if status == "destroy" then
				spell:Destroy()
				table.remove(activeSpells, i)
			end
		end
	end
end)


-- =================================================================
-- SECTION 6: NETWORK LAYER & CLEANUP (The Connection to the Game)
-- =================================================================
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Connection for "instant" spells
ReplicatedStorage.remotesEvent.spell.OnServerEvent:Connect(function(player, spellName, target)
	SpellManager.CastSpell(player, spellName, target)
end)

-- Connections for the channeled laser spell
ReplicatedStorage.remotesEvent.Laser.OnServerEvent:Connect(function(player, eventType, mousePosition)
	if eventType == "Start" then
		SpellManager.StartChanneling(player, mousePosition)
	elseif eventType == "Stop" then
		SpellManager.StopChanneling(player)
	end
end)

-- When a player leaves, we clean up their data to prevent memory leaks
Players.PlayerRemoving:Connect(function(player)
	if playerData[player] then
		playerData[player] = nil
	end
	if activeSpells[player] then
		SpellManager.StopChanneling(player)
	end
end)

-- The script is now ready and running.
return SpellManager
